#!/usr/bin/env python
"""
Copyright (c) 2013 Fraunhofer FKIE

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions
are met:

 * Redistributions of source code must retain the above copyright
   notice, this list of conditions and the following disclaimer.
 * Redistributions in binary form must reproduce the above copyright
   notice, this list of conditions and the following disclaimer in the
   documentation and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
"""
import os
import sys
# If run from the source tree
libdir = os.path.join(sys.path[0], "lib")
if os.path.isdir(os.path.join(libdir, "catkin_lint")): sys.path.insert(0, libdir)

import re
from catkin_pkg.packages import find_packages
from catkin_lint import __version__ as catkin_lint_version
import catkin_lint.cmake as cmake

# Immutable variables must not be changed at all
immutable_vars = frozenset([ 
    "CMAKE_C_COMPILER",
    "CMAKE_CXX_COMPILER",
    "PROJECT_NAME",
    "EXECUTABLE_OUTPUT_PATH",
    "LIBRARY_OUTPUT_PATH"
])
# Critical variables contain important values that must not be overwritten,
# but appending additional items is okay
critical_vars = frozenset([
    "CMAKE_C_FLAGS",
    "CMAKE_CXX_FLAGS",
    "CMAKE_INCLUDE_PATH",
    "CMAKE_LIBRARY_PATH",
    "CMAKE_FIND_ROOT_PATH",
    "CMAKE_MODULE_PATH","CMAKE_PREFIX_PATH"
])
# Singleton commands may not appear more than once
singleton_cmds = frozenset([
    "project",
    "generate_messages",
    "catkin_package",
    "catkin_metapackage",
    "catkin_python_setup"
])

def check_catkin_pkg(path, manifest, warnings, errors, is_ros_package):
    pkg_buildtool_dep = set([dep.name for dep in manifest.buildtool_depends])
    pkg_build_dep = set([dep.name for dep in manifest.build_depends])
    pkg_run_dep = set([dep.name for dep in manifest.run_depends])
    in_macro = False
    in_function = False
    cmlist = open(os.path.join(path, "CMakeLists.txt"), "r")
    cm_build_dep = set([])
    cm_run_dep = set([])
    cm_msg_dep = set([])
    cm_finds = set([])
    cm_commands = set([])
    cm_build_bins = set([])
    cm_build_libs = set([])
    cm_build_includes = set([])
    cm_export_libs = set([])
    cm_export_targets = set([])
    cm_target_outputs = {}
    cm_targets = set([])
    cm_installs = set([])
    cm_install_files = set([])
    cm_install_dirs = set([])
    cm_internal_deps = {}
    declares_messages = False
    has_catkin_stuff = False
    exports_includes = False
    installs_includes = False
    uses_rosbuild_compat = False
    short_name = manifest.name[:-5] if manifest.name.endswith("_fkie") else manifest.name
    var = {
      "CMAKE_CURRENT_SOURCE_DIR" : "/pkg-source/",
      "CMAKE_CURRENT_BINARY_DIR" : "/pkg-build/",
      "CATKIN_PACKAGE_BIN_DESTINATION" : "/catkin-target/lib/%s/" % manifest.name,
      "CATKIN_PACKAGE_ETC_DESTINATION" : "/catkin-target/etc/%s/" % manifest.name,
      "CATKIN_PACKAGE_INCLUDE_DESTINATION" : "/catkin-target/include/%s/" % manifest.name,
      "CATKIN_PACKAGE_LIB_DESTINATION" : "/catkin-target/lib/%s/" % manifest.name,
      "CATKIN_PACKAGE_PYTHON_DESTINATION" : "/catkin-target/share/python/%s/" % manifest.name,
      "CATKIN_PACKAGE_SHARE_DESTINATION" : "/catkin-target/share/%s/" % manifest.name,
      "CATKIN_GLOBAL_BIN_DESTINATION" : "/catkin-target/bin/",
      "CATKIN_GLOBAL_ETC_DESTINATION" : "/catkin-target/etc/",
      "CATKIN_GLOBAL_INCLUDE_DESTINATION" : "/catkin-target/include/",
      "CATKIN_GLOBAL_LIB_DESTINATION" : "/catkin-target/lib/",
      "CATKIN_GLOBAL_LIBEXEC_DESTINATION" : "/catkin-target/lib/",
      "CATKIN_GLOBAL_PYTHON_DESTINATION" : "/catkin-target/python/",
      "CATKIN_GLOBAL_SHARE_DESTINATION" : "/catkin-target/share/",
      "catkin_INCLUDE_DIRS" : "/catkin-includes/",
      "catkin_LIBRARIES" : "/catkin-libs/library.so",
    }
    for key in critical_vars:
        var[key] = "@%s@" % key
    for cmd, args in cmake.parse(cmlist.read(), var):
        if cmd in cm_commands & singleton_cmds:
            errors.append((manifest.name, "duplicate call to %s()" % cmd))
        cm_commands.add(cmd)
        if cmd.startswith("fkie_"):
            uses_rosbuild_compat = True
        if in_macro:
            if cmd == "endmacro": in_macro = False
            continue
        elif cmd == "macro":
            in_macro = True
            continue
        if in_function:
            if cmd == "endfunction": in_function = False
            continue
        elif cmd == "function":
            in_function = True
            continue
        if cmd == "project":
            var["PROJECT_NAME"] = args[0]
            if args[0] != manifest.name:
                errors.append((manifest.name, "project name '%s' differs from package name" % args[0]))
        if cmd == "find_package" or cmd == "fkie_find_package":
            if args[0] in cm_finds:
                errors.append((manifest.name, "duplicate call to find_package(%s)" % args[0]))
            cm_finds.add(args[0])
            if args[0] == "catkin":
                has_catkin_stuff = True
                if not "project" in cm_commands:
                    errors.append((manifest.name, "project() must occur before find_package(catkin)"))
                if cmd == "fkie_find_package":
                    warnings.append((manifest.name, "fkie_find_package(catkin) is deprecated"))
                opts, args = cmake.argparse(args, { "REQUIRED": "-", "COMPONENTS": "*" })
                if not opts["REQUIRED"]:
                    warnings.append((manifest.name, "find_package(catkin) should be used with REQUIRED keyword"))
                for pkg in opts["COMPONENTS"]:
                    if not is_ros_package(pkg):
                        errors.append((manifest.name, "'%s' is in COMPONENTS list in find_package(catkin) but not a catkin package" % pkg))
                cm_build_dep |= set(opts["COMPONENTS"])
            else:
                var["%s_INCLUDE_DIRS" % args[0]] = "/find-path/"
                var["%s_LIBRARIES" % args[0]] = "/find-lib/library.so"
            continue
        if cmd == "find_path":
            var[args[0]] = "/find-path/"
            continue
        if cmd == "find_library":
            var[args[0]] = "/find-lib/library.so"
            continue
        if cmd == "add_message_files" or cmd == "add_service_files" or cmd == "add_action_files":
            declares_messages = True
            has_catkin_stuff = True
            if manifest.is_metapackage():
                errors.append((manifest.name, "%s() is not allowed in catkin meta packages" % cmd))
            if not "catkin" in cm_finds:
                errors.append((manifest.name, "%s() must not occur before find_package(catkin)" % cmd))
            if "generate_messages" in cm_commands:
                errors.append((manifest.name, "%s() must not occur after generate_messages()" % cmd))
            continue
        if cmd == "generate_messages":
            has_catkin_stuff = True
            if manifest.is_metapackage():
                errors.append((manifest.name, "%s() is not allowed in catkin meta packages" % cmd))
            if not "catkin" in cm_finds:
                errors.append((manifest.name, "%s() must not occur before find_package(catkin)" % cmd))
            if "catkin_package" in cm_commands:
                errors.append((manifest.name, "%s() must not occur after catkin_package()" % cmd))
            opts, args = cmake.argparse(args, { "DEPENDENCIES": "*" })
            cm_msg_dep |= set(opts["DEPENDENCIES"])
            continue
        if cmd == "catkin_package":
            has_catkin_stuff = True
            if manifest.is_metapackage():
                errors.append((manifest.name, "meta package needs catkin_metapackage() instead of catkin_package()"))
            if not "catkin" in cm_finds:
                errors.append((manifest.name, "%s() must not occur before find_package(catkin)" % cmd))
            opts, args = cmake.argparse(args, { "INCLUDE_DIRS": "*", "LIBRARIES": "*", "DEPENDS": "*", "CATKIN_DEPENDS": "*", "CFG_EXTRAS": "*", "EXPORTED_TARGETS": "*" })
            for f in opts["CFG_EXTRAS"]:
                if not re.match(r'.*\.(cmake|cmake(\.develspace|\.installspace)?(\.em|\.in))', f):
                    errors.append((manifest.name, "%s() CFG_EXTRAS file '%s' has invalid extension" % (cmd, f)))
            for pkg in opts["CATKIN_DEPENDS"]:
                if not is_ros_package(pkg):
                    errors.append((manifest.name, "'%s' is in CATKIN_DEPENDS but not a catkin package" % pkg))
            for pkg in opts["DEPENDS"]:
                if is_ros_package(pkg):
                    errors.append((manifest.name, "'%s' is a catkin package and must be listed in CATKIN_DEPENDS" % pkg))
                elif not pkg in cm_finds and not ("%s_INCLUDE_DIRS" % pkg in var and "%s_LIBRARIES" % pkg in var):
                    errors.append((manifest.name, "'%s' in DEPENDS is neither find_package()'d nor has '%s_INCLUDE_DIRS' and '%s_LIBRARIES' defined" % (pkg, pkg, pkg)))
            for d in opts["INCLUDE_DIRS"]:
                if not os.path.isabs(d): d = "/pkg-source/%s" % d
                if not d.startswith("/find-path/") and not d.startswith("/pkg-"):
                    errors.append((manifest.name, "catkin_package() exports hard-coded path %s" % d))
                if d.startswith("/pkg-source/"):
                    exports_includes = True
            cm_run_dep |= set(opts["CATKIN_DEPENDS"])
            cm_export_libs |= set(opts["LIBRARIES"])
            cm_export_targets |= set(opts["EXPORTED_TARGETS"])
            continue
        if cmd == "catkin_metapackage":
            has_catkin_stuff = True
            if not manifest.is_metapackage():
                errors.append((manifest.name, "%s() is allowed in catkin meta packages only" % cmd))
            if not "catkin" in cm_finds:
                errors.append((manifest.name, "%s() must not occur before find_package(catkin)" % cmd))
            continue
        if cmd == "include_directories":
            cm_build_includes |= set(args)
            continue
        if cmd == "link_directories":
            externals = [ p for p in args if os.path.isabs(p) and not p.startswith("/pkg-") ]
            if externals:
                errors.append((manifest.name, "%s() must not be used for external dependencies" % cmd))
            else:
                warnings.append((manifest.name, "use of %s() is strongly discouraged" % cmd))
            continue
        if cmd == "target_link_libraries":
            if not cm_internal_deps.has_key(args[0]): cm_internal_deps[args[0]] = set([])
            cm_internal_deps[args[0]] |= set([ a for a in args[1:] if not a.startswith("/") ])
            continue
        if cmd == "add_library" or cmd == "add_executable":
            cm_targets.add(args[0])
            if cmd == "add_library": cm_build_libs.add(args[0])
            if cmd == "add_executable": cm_build_bins.add(args[0])
            if not cm_target_outputs.has_key(args[0]): cm_target_outputs[args[0]] = args[0]
            if manifest.is_metapackage():
                errors.append((manifest.name, "%s() is not allowed in catkin meta packages" % cmd))
            if not "catkin" in cm_finds:
                errors.append((manifest.name, "%s() must not occur before find_package(catkin)" % cmd))
            if not "catkin_package" in cm_commands:
                errors.append((manifest.name, "%s() must not occur before catkin_package()" % cmd))
            continue
        if cmd == "set_target_properties":
            opts, args = cmake.argparse(args, { "PROPERTIES" : "p" })
            for target in args:
                if opts["PROPERTIES"].has_key("OUTPUT_NAME"): cm_target_outputs[target] = opts["PROPERTIES"]["OUTPUT_NAME"]
            continue
        if cmd == "add_custom_target":
            cm_targets.add(args[0])
            continue
        if cmd == "set":
            if args[0] == "CMAKE_BUILD_TYPE":
                warnings.append((manifest.name, "variable CMAKE_BUILD_TYPE should not be set"))
            elif args[0] in immutable_vars:
                errors.append((manifest.name, "variable %s must not be set" % args[0]))
            elif args[0] in critical_vars:
                value = ';'.join(args[1:])
                if not "@%s@" % args[0] in value: 
                    errors.append((manifest.name, "original value of variable %s is lost" % args[0]))
                else:
                    warnings.append((manifest.name, "variable %s should not be modified" % args[0]))
            else:
                var[args[0]] = ';'.join(args[1:])
            continue
        if cmd == "unset":
            if args[0] in critical_vars + immutable_vars + [ "CMAKE_BUILD_TYPE" ]:
                errors.append((manifest.name, "variable %s must not be unset" % args[0]))
            else:
                var[args[0]] = ""
            continue
        if cmd == "catkin_python_setup":
            has_catkin_stuff = True
            if not "catkin" in cm_finds:
                errors.append((manifest.name, "%s() must not occur before find_package(catkin)" % cmd))
            if not os.path.exists(os.path.join(path, "setup.py")):
                errors.append((manifest.name, "%s() needs a setup.py in the package folder" % cmd))
            continue
        if cmd == "install":
            install_type = ""
            opts, args =  cmake.argparse(args, { "PROGRAMS" : "*", "FILES": "*", "TARGETS": "*", "DIRECTORY" : "?", "DESTINATION" : "?", "ARCHIVE DESTINATION": "?", "LIBRARY DESTINATION": "?", "RUNTIME DESTINATION": "?" })
            if opts["PROGRAMS"]:
                install_type = "PROGRAMS"
            if opts["DIRECTORY"]:
                install_type = "DIRECTORY"
            if opts["TARGETS"]:
                install_type = "TARGETS"
                cm_installs |= set(opts["TARGETS"])
            if opts["FILES"]:
                install_type = "FILES"
                cm_install_files |= set([os.path.normpath(os.path.join(opts["DESTINATION"], f)) for f in opts["FILES"] ])
            for dest in [ "DESTINATION", "ARCHIVE DESTINATION", "LIBRARY DESTINATION", "RUNTIME DESTINATION" ]:
                if not opts[dest]: continue
                if not opts[dest].startswith("/catkin-target/"):
                    warnings.append((manifest.name, "install(%s ... %s) should use one of the ${CATKIN_*_DESTINATION} variables" % (install_type, dest)))
                if opts[dest].startswith("/catkin-target/include/"):
                    installs_includes = True
            continue
    if "rosbuild_compat_fkie" in pkg_buildtool_dep | pkg_build_dep and not uses_rosbuild_compat:
        warnings.append((manifest.name, "'rosbuild_compat_fkie' is a dependency but not used"))
    if uses_rosbuild_compat and not "rosbuild_compat_fkie" in pkg_buildtool_dep:
        if not "rosbuild_compat_fkie" in pkg_build_dep:
            errors.append((manifest.name, "missing buildtool_depend 'rosbuild_compat_fkie'"))
        else:
            warnings.append((manifest.name, "'rosbuild_compat_fkie' should be a buildtool_depend"))
    if "catkin" in pkg_buildtool_dep:
        if not "catkin" in cm_finds:
            errors.append((manifest.name, "missing find_package(catkin) command"))
        if not "catkin_package" in cm_commands and not manifest.is_metapackage():
            errors.append((manifest.name, "missing catkin_package() command"))
        if not "catkin_metapackage" in cm_commands and manifest.is_metapackage():
            errors.append((manifest.name, "missing catkin_metapackage() command"))
    elif has_catkin_stuff:
        errors.append((manifest.name, "need 'catkin' as buildtool_depend in package.xml"))
    if "generate_messages" in cm_commands and not declares_messages:
        warnings.append((manifest.name, "generate_messages() called but nothing declared to be generated"))
    if declares_messages and not "generate_messages" in cm_commands:
        errors.append((manifest.name, "missing generate_messages() after add_*_files()"))
        cm_commands.add("generate_messages") # Fake it
    if declares_messages and not "message_generation" in cm_build_dep and not manifest.is_metapackage():
        errors.append((manifest.name, "'message_generation' is not in COMPONENTS in find_package(catkin)"))
    if declares_messages and not "message_runtime" in cm_run_dep and not manifest.is_metapackage():
        errors.append((manifest.name, "'message_runtime' is not in CATKIN_DEPENDS in catkin_package()"))
    if cm_targets and cm_build_dep and not "/catkin-includes/" in cm_build_includes:
        warnings.append((manifest.name, "include_directories() should list ${catkin_INCLUDE_DIRS}"))
    if exports_includes and not installs_includes:
        msg = (manifest.name, "catkin_package() INCLUDE_DIRS contains package dir but none is installed")
        if "install" in cm_commands:
            errors.append(msg)
        else:
            warnings.append(msg)
    if os.path.exists(os.path.join(path, "setup.py")) and not "catkin_python_setup" in cm_commands:
        errors.append((manifest.name, "setup.py in package folder but no call to catkin_python_setup()"))
    if exports_includes and cm_build_libs and not cm_export_libs:
        warnings.append((manifest.name, "catkin_package() exports include path but no library"))
    for pkg in cm_msg_dep - cm_build_dep - cm_finds:
        errors.append((manifest.name, "'%s' from generate_messages() is not find_package()'d" % pkg))
    for pkg in cm_msg_dep - pkg_build_dep:
        errors.append((manifest.name, "'%s' from generate_messages() is not a build_depend in package.xml" % pkg))
    for pkg in cm_msg_dep - cm_run_dep:
        errors.append((manifest.name, "'%s' from generate_messages() is not listed in catkin_package()" % pkg))
    for pkg in cm_msg_dep - pkg_run_dep:
        errors.append((manifest.name, "'%s' from generate_messages() is not a run_depend in package.xml" % pkg))
    for lib in (cm_export_libs - cm_installs) & cm_targets:
        msg = (manifest.name, "catkin_package() exports library '%s' that is not installed" % lib)
        if "install" in cm_commands:
            errors.append(msg)
        else:
            warnings.append(msg)
    for tgt in cm_build_bins - cm_installs - cm_export_libs:
        if "test" in tgt: continue
        warnings.append((manifest.name, "target '%s' is not installed" % tgt))
    for pkg in cm_build_dep - cm_run_dep:
        if re.match(r"_msgs(_|$)", pkg) and is_ros_package(pkg):
            warnings.append((manifest.name, "'%s' should probably be in CATKIN_DEPENDS in catkin_package()" % pkg))
    for pkg in cm_build_dep - pkg_build_dep:
        if pkg == "rosbuild_compat_fkie" and pkg in pkg_buildtool_dep: continue
        errors.append((manifest.name, "'%s' is not a build_depend in package.xml" % pkg))
    for pkg in pkg_build_dep - cm_build_dep - cm_finds:
        if is_ros_package(pkg):
            errors.append((manifest.name, "'%s' is a build_depend but not find_package()'d" % pkg))
    for pkg in cm_run_dep - pkg_run_dep:
        errors.append((manifest.name, "'%s' is not a run_depend in package.xml" % pkg))
    for tgt in cm_export_targets - cm_targets:
        errors.append((manifest.name, "target '%s' is exported but not defined" % tgt))
    for target, output in cm_target_outputs.iteritems():
        if os.sep in output:
            errors.append((manifest.name, "output name of target '%s' contains %s character" % (target, os.sep)))
        if not short_name in target:
            warnings.append((manifest.name, "target '%s' should contain package name to make it unique in any catkin workspace" % target))
    for target, depends in cm_internal_deps.iteritems():
        if not target in cm_installs: continue
        for lib in depends:
            if not lib in cm_targets: continue
            if not lib in cm_installs:
                errors.append((manifest.name, "library '%s' is linked by installed target '%s' but not installed itself" % (lib, target)))
    if manifest.is_metapackage() and (len(cm_build_dep) > 0 or len(pkg_build_dep) > 0):
        errors.append((manifest.name, "meta packages must not have build_depends"))
    cm_plugin_dep = set([])
    for export in manifest.exports:
        if "plugin" in export.attributes.keys():
            plugin = export.attributes["plugin"]
            cm_plugin_dep.add(export.tagname)
            if not plugin.startswith("${prefix}/"):
                errors.append((manifest.name, "%s plugin export must start with '${prefix}/'" % export.tagname))
            else:
                if not os.path.exists(os.path.join(path, plugin[10:])):
                    errors.append((manifest.name, "%s plugin export '%s' refers to missing file" % (export.tagname, plugin)))
                if not os.path.normpath("/catkin-target/share/%s/%s" % (manifest.name, plugin[10:])) in cm_install_files:
                    msg = (manifest.name, "%s plugin export '%s' is not installed to ${CATKIN_PACKAGE_SHARE_DESTINATION}" % (export.tagname, plugin[10:]))
                    if "install" in cm_commands:
                        errors.append(msg)
                    else:
                        warnings.append(msg)
    for dep in cm_plugin_dep - pkg_run_dep:
        warnings.append((manifest.name, "package exports %s plugin but does not run_depend on '%s'" % (dep, dep)))
    chatter = re.match(r"((\s|[.,!?;()])*\b(%s|a\s+few|the|an?|packages?|contain(s|ed)?|comprise(d|s)?|include(s|d)?|provide(s|ed)?|suppl(y|ies|ied)?|offer(s|ed)?|add(s|ed)?|can|be|use[sd]?|runs?|sets?|is|are|has|have|had|do(es)?|did|this|these|those|that|which|(ros\s+)?nodes?|from|in|to|for|of|with|and|or|purpose|multiple|several|(an)?other|one|two|three|both|some|all|no(thing|ne|t)?|various|different|miscellaneous|routines?|(python\s+|c(\+\+)?\s+|java\s+)?code(\s+snippets?)?|useful|examples?|boilerplate|meaningless|programs?|executables?|versions?|work\s+in\s+progress|todo|descriptions?|interfaces?|implementations?|librar(y|ies)|functionalit(y|ies)|\d+)\b)+" % manifest.name, manifest.description, re.IGNORECASE)
    if chatter is not None:
        s = chatter.group(0).replace("\n", " ").strip()
        if manifest.description[chatter.end(0):].strip():
            if len(s.split()) > 1:
                warnings.append((manifest.name, "package description starts with boilerplate '%s'" % s))
        else:
            warnings.append((manifest.name, "meaningless package description '%s'" % s))

if __name__ == "__main__":
    try:
        import sys
        import argparse
        parser = argparse.ArgumentParser()
        parser.add_argument("--version", action="version", version=catkin_lint_version)
        parser.add_argument("path", nargs="*", default=[], help="path to catkin packages")
        parser.add_argument("-w", "--warn", action="store_true", help="show warnings")
        parser.add_argument("-s", "--strict", action="store_true", help="treat warnings as errors")
        args = parser.parse_args()
        warnings = []
        errors = []
        pkgs = {}
        local_pkg_names = set([])
        pkgs_to_check = []
        warn_suppressed = 0
        nothing_to_do = 0
        if "ROS_PACKAGE_PATH" in os.environ:
            for path in os.environ["ROS_PACKAGE_PATH"].split(os.pathsep):
                pkgs = find_packages(path)
                local_pkg_names |= set([m.name for m in pkgs.values() ])
                h, t = os.path.split(path)
                if t == "src":
                    repodir = os.path.join(h, "repos")
                    if os.path.isdir(repodir):
                        pkgs = find_packages(repodir)
                        local_pkg_names |= set([m.name for m in pkgs.values() ])
        if not args.path:
            if os.path.exists("package.xml"):
                args.path += [ "." ]
            else:
                sys.stderr.write("catkin_lint: no path given and no package.xml in current directory\n")
                sys.exit(1)
        for path in args.path:
            path = os.path.normpath(path)
            if not os.path.isdir(path):
                sys.stderr.write ("catkin_lint: %s is not a directory\n" % path)
                nothing_to_do = 1
                continue
            pkgs = find_packages(path)
            local_pkg_names |= set([ m.name for m in pkgs.values() ])
            pkgs_to_check += [ (os.path.join(path, p), m) for p,m in pkgs.iteritems() ]
        if not pkgs_to_check:
            sys.stderr.write ("catkin_lint: no packages to check\n")
            sys.exit(nothing_to_do)
        for path, manifest in pkgs_to_check:
            try:
                check_catkin_pkg(path, manifest, warnings, errors, lambda pkg: pkg in local_pkg_names)
            except Exception as e:
                errors.append((manifest.name, str(e)))
        if args.strict:
            errors = warnings + errors
            warnings = []
        if not args.warn:
            warn_suppressed = len(warnings)
            warnings = []
        for pkg, msg in sorted(warnings):
            sys.stdout.write("%s: warning: %s\n" % (pkg, msg))
        for pkg, msg in sorted(errors):
            sys.stdout.write("%s: error: %s\n" % (pkg, msg))
        if errors and warnings:
            sys.stderr.write ("catkin_lint: checked %d packages and found %d warnings and %d errors\n" % (len(pkgs_to_check), len(warnings), len(errors)))
        elif errors and not warnings:
            sys.stderr.write ("catkin_lint: checked %d packages and found %d errors\n" % (len(pkgs_to_check), len(errors)))
        elif warnings and not errors:
            sys.stderr.write ("catkin_lint: checked %d packages and found %d warnings\n" % (len(pkgs_to_check), len(warnings)))
        else:
            sys.stderr.write ("catkin_lint: checked %d packages and found no problems\n" % len(pkgs_to_check))
        if (warn_suppressed): sys.stderr.write ("catkin_lint: %d warnings have been ignored. Use --warn to show them\n" % warn_suppressed)
        sys.exit(1 if errors else 0)
    except Exception as err:
        sys.stderr.write("catkin_lint: %s\n\n" % str(err))
        sys.exit(2)

